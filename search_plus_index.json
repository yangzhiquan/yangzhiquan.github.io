{"./":{"url":"./","title":"Introduction","keywords":"","body":"我的 GitBook [iOS单元测试](./CleanCoder/iOS-Unit-Testing.md) | 学而不思则惘，思而不学则殆 --> 以上文档由 yvan 编写，转载请遵循知识共享许可协议 --> By yvan            last update： 2022-09-22 02:14:20 "},"iOS/boot.html":{"url":"iOS/boot.html","title":"iOS应用的编译与运行","keywords":"","body":"[TOC] 一：iOS基础：编译、启动与运行 AOT与JIT, 编译器与解释器 高级语言代码都需要转换成二进制码才能被CPU执行, 转换方式分为两种: 一是运行前编译好，AOT(Ahead of Time)，转换的程序称为编译器. 二是运行中逐条翻译成二进制码.JIT(Just In Time). 转换程序称为解释器. 解释器：在运行时依次获取每一段代码将其翻译成目标代码（字节码），一句一句地执行. 编译器：把一种编程语言转换为另一种编程语言的程序（原始语言到目标语言） 编译器的前端和后端 前端：前端负责语法分析、词法分析，生成中间代码 后端：后端以中间代码作为输入，进行架构无关的代码优化，接着针对不同架构生成不同的机器码 Xcode使用的编译器前端是clang,后端LLVM LLVM 是编译器工具链技术的一个集合。其中的lld，就是内置链接器。编译器会对每个文件进行编译，生成 Mach-O（可执行文件）；链接器会将项目中的多个 Mach-O 文件合并成一个。 编译过程 前端: 预处理：Clang预处理代码（替换宏、删注释、条件编译 词法分析：词法分析器读入源文件的字符流，将他们组织称有意义的词素(lexeme)序列，对于每个词素，此法分析器产生词法单元（token）作为输出。并且会用Loc来记录位置。 语法分析：把词法分析生成的标记流，解析成一个抽象语法树（abstract syntax tree -- AST）,同样地，在这里面每一节点也都标记了其在源码中的位置。 AST 是抽象语法树，结构上比代码更精简，遍历起来更快，所以使用 AST 能够更快速地进行静态检查。 静态分析：把源码转化为抽象语法树之后，编译器就可以对这个树进行静态分析处理。静态分析会对代码进行错误检查，如出现方法被调用但是未定义、定义但是未使用的变量等，以此提高代码质量。最后 AST 会生成 IR，IR 是一种更接近机器码的语言，区别在于和平台无关，通过 IR 可以生成多份适合不同平台的机器码。 静态分析的阶段会进行类型检查，比如给属性设置一个与其自身类型不相符的对象，编译器会给出一个可能使用不正确的警告。在此阶段也会检查时候有未使用过的变量等。 后端: 中间代码生成和优化：此阶段LLVM 会对代码进行编译优化，例如针对全局变量优化、循环优化、尾递归优化等，最后输出汇编代码 xx.ll文件。 生成汇编代码： 汇编器LLVM会将汇编码转为机器码。生成二进制.o文件。 链接：连接器把编译产生的.o文件和（dylib,a,tbd）文件，生成可执行文件mach-o文件。 Mach Object文件 通过clang -c demo.c 生成.o文件 file demo.o命令查看.o文件 主要部分 Header：文件的目标cpu架构等基本信息。 struct mach_header_64 { uint32_t magic; // 64位还是32位 cpu_type_t cputype; cpu_subtype_t cpusubtype; // CPU 子类型，比如 armv8 CPU_SUBTYPE_ARM_64 uint32_t filetype; // 文件类型 MH_EXECUTE uint32_t ncmds; // load commands 的数量 uint32_t sizeofcmds; // load commands 大小 uint32_t flags; // 标签 uint32_t reserved; // 保留字段 }; Load Commands：文件的逻辑结构和在虚拟内存中的布局，告诉加载器如何加载每个Segment的信息（Mach-O文件可以有多个Segment，每个Segment可能有一个或多个 Section） Data（数据区），Segment的具体数据，包含了代码和数据等。 具体部分 文件头 mach64 Header 加载命令 Load Commands 文本段 __TEXT 数据段 __DATA 动态库加载信息 Dynamic Loader Info 入口函数 Function Starts 符号表 Symbol Table 动态库符号表 Dynamic Symbol Table 字符串表 String Table 链接器 绑定代码变量、函数符号跟它们内存地址; 比如 if、for、while 生成的机器指令序列，要操作的数据会存储在某个地方，变量符号就需要绑定到数据的存储地址。代码还会引用其他的代码，引用的函数符号也需要绑定到该函数的地址上。（否则要让机器知道你在操作什么内存地址，你就需要在写代码时给每个指令设好内存地址。 符号: 变量/函数名.. 代码 与 数据: 代码编译之后，函数分为函数名跟实现两部分，变量也分为变量名跟值. 前者称为符合，后者为数据，它们通过符合表关联. 合并mach-o: 编译过程链接器把每个文件生的.o文件合成一个；过程中会创建一个全局符号表，将所有符号定义和引用地址收集起来，记录所有已定义的和所有未定义的符号。 对项目中不同文件里的变量进行地址重定位（rebind）. 链接时如果出现相同符号的情况，就会出现“ld: dumplicate symbols”的错误信息；如果在其他目标文件里没有找到符号，就会提示“Undefined symbols”的错误信息。（不合并为一个的话，引用其他文件函数就找不到地址了）.最终链接器会用函数的实际地址来代替函数引用(符号)。 Dead code stripping: 链接器以 main 函数为源头，跟随每个引用，并将其标记为 live，整理函数的调用关系时。未被标记 live 的函数，就是无用函数。默认开启的Dead code stripping选项会去除无用代码的功能。 `` 动态库链接 前面提到链接器会把项目文件合并为一个Mach-O文件，包括工程引入的静态库。但不是所有的外部文件调用都会被合并编译. 比如引用系统库(UI、网络、IO)，它们是以动态库的形式，在应用启动的时候，通过动态连接器(dyld)动态加载到程序的进程空间。（编译阶段的是静态链接器） dylib格式的库，表示是动态链接的，编译的时候不会被编译到执行文件中，不增加包大小。 在编译链接过程，引用动态库的符合会特殊标记为\"未定义\"并记录库地址，运行时通过 dlopen 和 dlsym 导入动态库时，先根据记录的库路径找到对应的库，再通过记录的名字符号找到绑定的地址。并将二进制产物中的这些 unbound symbol 所对应的地址修正为内存中这些符号的实际地址. dlopen载入的动态库，如果该库也有未定义的其他库地址，还会继续导入相关的库 动态库可以启动时绑定，或者符号第一次被用到时绑定。为了减少启动时间，大部分动态库使用的都是符号第一次被用到时再绑定的方式。 ASLR: 程序每次启动都会有一个偏移量(固定地址容易被识别hack)，加载过程修正地址偏移后。除了lazy的指针外都进行符号地址绑定 系统上的动态链接器会使用共享缓存，共享缓存在 /var/db/dyld/。当加载 Mach-O 文件时，动态链接器会先检查是否有共享缓存。每个进程都会在自己的地址空间映射这些共享缓存，这样做可以起到优化 App 启动速度的作用。 *原理应用：开发过程用动态库的原理，只编译修改的文件，加快编译调试速度 动态库与静态库 静态和动态是指链接发生在编译阶段和还是运行阶段. 1.静态库： 以 “.a” 或者 “.framework” 为文件后缀名；..a + .h + sourceFile = .framework. 模块化，分工合作，提高了代码的复用及核心技术的保密程度； 编辑阶段用到的部分会被链接进主Mach-O. 避免少量改动经常导致大量的重复编译连接； 不影响启动时间 2.动态库： 以 “.tbd/dylib” 或者 “.framework” 为文件后缀名。 不像静态库在编译阶段把所有引用编入，动态库只增加自身二进制部分，引用外部的代码运行时才链接，这部分不增加文件体积；但静态库有编译优化去重，最终影响并不明显. 多个应用程序共享内存中得同一份库文件，节省资源； 占用启动时间 系统动态库在动态库空间，app共享。应用使用的动态库仅能在host app跟extension之间使用. 二：iOS应用启动过程 打印pre_main的耗时：DYLD_PRINT_STATISTICS Total pre-main time总耗时如果大于20s会被系统watch dog杀掉。 - 系统创建进程，内核将App的执行文件、dyld的执行文件Mach-O加载到随机地址空间(ASLR)，根据文件内容映射到逻辑地址空间. - 系统将控制权交给Dyld来启动应用 【dylib loading】，加载可执行文件(App的.o文件的集合，所需的动态链接库) dyld读取mach-o文件的Header和load commands。 解析出App依赖的dylib列表，找到每一个依赖的dylib。例如加载动态库A到内存，接着检查A所依赖的动态库，就这样的递归加载，直到所有的动态库加载完毕。(有缓存到dyld shared cache) 【rebase/binding time】，对动态链接库进行 rebase 指针调整和 bind 符号绑定。先是调用recursiveRebase()函数对动态库进行基地址的复位，然后调用 recursiveBind()函数对动态库进行non-lazy符号绑定，一般的情况下多数符号都是lazy的，他们在第一次使用的时候才进行绑定。 【Objc setup】OC runtime运行时的初始处理，包括 Objc 相关类的注册、category 注册、selector 唯一性检查等 【initializer】包括了执行 +load() 方法、attribute((constructor)) 修饰的函数的调用、创建 C++ 静态全局变量 【main】 为什么需要Rebase 和 Bind？ ASLR使得执行文件映射到虚拟内存地址随机化，起始地址不固定，文件中写的函数地址跟载入的函数地址有差异。修复这个差异的过程就是rebasing和binding。 Rebase：Rebasing过程就是从__LINKEDIT取出函数指针，根据偏移量修改函数指针，存入__DATA中，Rebase解决了内部的符号引用问题。 Binding：当引用动态库其他的函数或者变量时，当前mach-o文件会指向其他dylib。这时候就需要Binding操作，dyld会根据符号表去找到相应函数和变量地址，Binding解决、修正外部指针指向的问题。 三：iOS应用运行 （BeforeWaiting: UI刷新、Autorelease pool） 系统注册了Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。 SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 点击屏幕上的按钮发生什么 NSObject > UIResponder > UIView > UIControl > UIButton 1. 主线程的RunLoop被唤醒 2. 通知Observer，处理Timer和Source 0 3. Springboard接受touch event之后转给App进程中 4. RunLoop处理Source 1，Source1 就会触发回调，并调用_UIApplicationHandleEventQueue() 进行应用内部的分发。 5. RunLoop处理完毕进入睡眠，此前会释放旧的autorelease pool并新建一个autorelease pool 6. 设备将touch到的UITouch和UIEvent对象打包, 放到当前活动的Application的事件队列中. 7. 单例的UIApplication会从事件队列中取出触摸事件并传递给单例UIWindow. 8. UIWindow使用hitTest:withEvent:方法查找touch操作的所在的视图view. RunLoop: 【main】函数传入AppDelagate实例，处理应用启动等回调事件. UI事件均在主线程处理，并默认开启RunLoop。（一个线程执行完任务便会销毁，RunLoop本质上是一种循环执行，让线程持续运行处理事件，控制线程休眠与唤醒） 子线程通过currentRunLoop触发runloop初始化, 两者对应存在全局表，线程销毁runloop也销毁。 RunLoop线程休眠是指切到内核态真正休眠线程，来消息了切回用户态响应。 RunLoop的工作: 处理event: Source1：系统内核的mach_msg事件（基于Port(端口)的线程间通信、系统事件捕捉:比如点击事件，通过Source1捕捉，然后包装成Source0进行处理） Source0：UIEvent触摸事件（Source1接收后通过Callback触发）;performSelector:onThread; （如果runloop在休眠阶段会唤醒并处理）（非基于Port的消息：指这个消息不是其他进程或者内核直接发送给你的。一般是APP内部的事件） Timer: 定时事件(NSTimer, 或者它的包装方法performSelector:withObject:afterDelay) Observer：runloop的状态变化时进行通知。（可以用一个子线程监听状态变化，观察主线程的处理耗时） main_queue: 主队列一定是在主线程处理的(GCD派发的，同步/异步/延迟的) RunLoop的工作Mode: kCFRunLoopDefaultMode：默认模式，通常主线程是在这个Mode下运行 UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 其他还有Initialization等3个Mode Runloop与渲染任务： 当[UIView setNeedsDisplay]，实际是执行[view.layer setNeedsDisplay]，给当前layer标记脏。等Runloop进到即将休眠阶段，也就是beforeWaiting时才会进行绘制。 调用[CALayer display]，进入到真正绘制的工作。判断delegate是否实现异步绘制的代理方法displayer（异步绘制的入口），如果没有则继续进行系统绘制的流程。 CALayer 内部会创建一个 Backing Store，用来获取图形上下文。接下来会判断是否有 delegate。没有则调用 [CALayer drawInContext:]。 如果有，则调用[layer.delegate drawLayer:inContext:]，返回[UIView DrawRect:]，在系统绘制的基础之上再做些额外的事。 最终CALayer都会将位图提交到 Backing Store，最后提交给 GPU。 --- 深入理解 Symbol 符号(Symbol)是日常开发中经常接触的一个概念，虽然日常开发中直接应用的场景比较少，但符号编译期和运行时都扮演了重要的角色。 符号是一个数据结构，包含了名称(String)和类型等元数据，符号对应一个函数或者数据的地址。 Symbol Table 符号表存储了当前文件的符号信息，静态链接器(ld)和动态链接器(dyld)在链接的过程中都会读取符号表，另外调试器也会用符号表来把符号映射到源文件。 如果把调试符号裁剪掉(Deployment Postprocessing选择为YES)，那么文件里的断点会失效(Build Settings的Deployment). Release模式下是可以裁剪掉符号的，因为release模式下默认有dsym文件，调试器仍然可以从中获取到信息正常工作。 符号表中存储符号的数据结构如下： struct nlist_64 { union { uint32_t n_strx; /* index into the string table */ } n_un; uint8_t n_type; /* type flag, see below */ uint8_t n_sect; /* section number or NO_SECT */ uint16_t n_desc; /* see */ uint64_t n_value; /* value of this symbol (or stab offset) */ }; 字符串存储在String Table里，String Table的格式很简单，就是一个个字符串拼接而成。符号的n_strx字段存储了符号的名字在String Table的下标。 Dynamic Symbol Table Dynamic Symbol Table是动态链接器(dyld)需要的符号表，是符号表的子集，对应的数据结构很简单，只存储了符号位于Symbol Table的下标： ➜ otool -I main main: ... Indirect symbols for (__DATA,__la_symbol_ptr) 1 entries address index 0x000000010000c000 4 //对应符号表的idx为4的符号 ... 既然Dynamic Symbol Table只存储了下标，这里otool是如何知道这个Indirect symbol属于DATA,la_symbol_ptr？ 答案是用section_64的reserved字段：如果一个section是DATA,la_symbol_ptr，那么它的reserved1字段会存储一个Dynamic Symbol Table下标。 struct section_64 { /* for 64-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint64_t addr; /* memory address of this section */ uint64_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */ uint32_t reserved3; /* reserved */ }; 所以，对于位于__la_symbol_ptr的指针，我们可以通过如下的方式来获取它的符号名： • 遍历load command，如果发现是DATA,la_symbol_ptr，那么读取reserved1，即__la_symbol_ptr的符号位于Dynamic Symbol Table的起始地址。 • 遍历DATA,la_symbol_ptr处的指针，当前遍历的下标为idx，加上reserved1就是该指针对应的Dynamic Symbol Table下标 • 通过Dynamic Symbol Table，读取Symbol Table的下标 • 读取Symbol Table，找到String Table的Index • 找到符号名称 一张图回顾整个过程，可以看到MachO中各种下标的利用很巧妙： fishhook就是利用类似的原理，遍历__la_symbol_ptr，比较指针背后的函数符号名称，如果只指定的字符串，就替换指针的指向。 DWARF vs DSYM DWARF(debugging with attributed record formats)是一种调试信息的存储格式，用在Object File里，用来支持源代码级别的调试。 用Xcode编译的中间产物ViewController.o，用MachOView打开后，可以看到很多DWARF的section: 打包上线的时候会把调试符号等裁剪掉，但是线上统计到的堆栈我们仍然要能够知道对应的源代码，这时候就需要把符号写到另外一个单独的文件里，这个文件就是DSYM。 可以通过命令dwarfdump来查询dsym文件的内容，比如查找一个地址 dwarfdump --lookup 0x0007434d -arch arm64 DemoApp.app.dsym crash堆栈还可以直接通过Xcode内置的命令来反符号化 export DEVELOPER_DIR=\"/Applications/Xcode.app/Contents/Developer\" alias symbolicatecrash='/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash' symbolicatecrash demo.crash DemoApp.app.dsym > result.crash 符号表裁剪 符号包含的信息太多，处于安全考虑，往往会进行最高级别的裁剪。对于.app，选择裁掉All Symbol，而动态库只能选择Non-Global Symbol，因为动态库需要把Global Symbol保留给外部链接用。 背后裁减的实际命令是strip，比如裁减local符号的指令是strip -x 符号生成规则 C的符号生成规则比较简单，一般的符号都是在函数名上加上下划线，比如main.c里包含mian和mylog两个C函数，对应符号如下： ➜ nm main.o 0000000000000000 T _main U _mylog C++因为支持命名空间，函数重载等高级特性，为了避免符号冲突，所以编译器对C++符号做了Symbol Mangling(不同编译器的规则不一样)。namespace MyNameSpace { class MyClass{ public: static int myFunc(int); static double myFunc(double); }; } // 编译后，分别对应符号 ➜ DemoApp nm DemoCpp.o 0000000000000008 T __ZN11MyNameSpace7MyClass6myFuncEd 0000000000000000 T __ZN11MyNameSpace7MyClass6myFuncEi 其实，Symbol Mangling规则并不难，刚刚的两个符号是按照如下规则生成的： • 以_Z开头 • 跟着C语言的保留字符串N • 对于namespace等嵌套的名称，接下依次拼接名称长度，名称 • 然后是结束字符E • 最后是参数的类型，比如int是i，double是d Objective-C的符号更简单一些，比如方法的符号是+-[Class_name(category_name) method:name:]，除了这些，Objective C还会生成一些Runtime元数据的符号 ➜ DemoApp nm ViewController-arm64.o U _OBJC_CLASS_$_BTDRouteBuilder U _OBJC_CLASS_$_BTDRouter U _OBJC_CLASS_$_UIViewController 0000000000000458 S _OBJC_CLASS_$_ViewController U _OBJC_METACLASS_$_NSObject U _OBJC_METACLASS_$_UIViewController 0000000000000480 S _OBJC_METACLASS_$_ViewController 运行时就用OBJC_CLASS$CLASSNAME作为参数，通过dlsym来获取类指针。所以当链接的时候类找不到了，会报错符号_OBJC_CLASS$CLASSNAME找不到 (`Undefined symbol: _OBJC_CLASS$_XXXClass`) 符号的种类 按照不同的方式可以对符号进行不同的分类，比如按照可见性划分 • 全局符号(Global Symbol) 对其他编译单元可见 • 本地符号(Local Symbol) 只对当前编译单元可见 按照位置划分： • 外部符号，符号不在当前文件，需要ld或者dyld在链接的时候解决 • 非外部符号，即当前文件内的符号 nm命令里的小写字母对应着本地符号，大写字母表示全局符号；U表示undefined，即未定义的外部符号 符号可见性 有个很常见的case，就是你有1000个函数，但只有10个函数是公开的，希望最后生成的动态库里不包含其他990个函数的符号，这时候就可以用clang的attribute来实现： //符号可被外部链接 __attribute__((visibility(\"default\"))) //符号不会被放到Dynamic Symbol Table里，意味着不可以再被其他编译单元链接 __attribute__((visibility(\"hidden\"))) clang来提供了一个全局的开关，用来设置符号的默认可见性：Build Settings -> Symbols Hidden by Default 如果动态库的Target把这个开关打开，会发现动态库仍然能编译通过，但是App会报一堆链接错误，因为符号变成了hidden。 但这是一种常见的编译方式：让符号默认是Hidden的，即-fvisibility=hidden，然后手动为每个接口加上attribute((visibility(\"default\")))。 //头文件 #define LH_EXPORT __attribute__((visibility(\"default\"))) LH_EXPORT void method_1(void); //实现文件 LH_EXPORT void method_1(){ NSLog(@\"1\"); } ld 刚刚提到了，链接的时候ld会解决重定位符号的问题，所以ld提供了很多与符号相关的选项。 -ObjC, -all_load, -force_load ld链接静态库的时候，只有.a中的某个.o符号被引用的时候，这个.o才会被链接器写到最后的二进制文件里，否则会被丢掉，这三个链接选项都是解决保留代码的问题。 • -ObjC 保留所有Objective C的代码 • -force_load 保留某一个静态库的全部代码 • -all_load 保留参与链接的全部的静态库代码 这就是为什么一些SDK在集成进来的时候，都要求在other link flags里添加-ObjC。 更多 reexport: 动态库A链接B，希望其他链接A动态库也能直接访问到B的符号，从而隐藏B的实现 exported_symbol: 从包大小的角度考虑，肯定是用到哪些符号，保留哪些符号对应的代码，ld提供了这样一个方案，通过exported_symbol来只保留特定的符号。 tbd: 链接的过程中，只要知道哪个动态库包括哪些符号即可，其实不需要一个完整的动态库Mach-O。于是Xcode 7开始引入了tbd的概念，即Text Based Stub Library(Build Setting -> Text-Based API)，里面包含了动态库对外提供的符号，能大幅度减少Xcode的下载大小。 tbd文件地址(文本格式)：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks flat_namespace: ld默认采用二级命名空间，也就是除了会记录符号名称，还会记录符号属于哪个动态库的. 可以强制让ld使用flat_namespace，使用一级命名空间，这样容易发生符号冲突，效率也低。但是可以实现动态库依赖主二进制这种操作。 运行时 bind: 应用会访问很多外部的符号，编译的时候是不知道这些符号的运行时地址的，所以需要在运行时绑定。 ➜ xcrun dyldinfo -bind main bind information: segment section address type addend dylib symbol __DATA_CONST __got x100008000 pointer 0 libSystem dyld_stub_binder 启动的时候，dyld会读取LINKEDIT中的opcode做绑定： ➜ xcrun dyldinfo -opcodes main binding opcodes: 0x0000 BIND_OPCODE_SET_DYLIB_ORDINAL_IMM(1) 0x0001 BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM(0x00, dyld_stub_binder) 0x0013 BIND_OPCODE_SET_TYPE_IMM(1) 0x0014 BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB(0x02, 0x00000000) 0x0016 BIND_OPCODE_DO_BIND() 0x0017 BIND_OPCODE_DONE Lazy Symbol 多数符号在应用的生命周期内是用不到的，于是ld会尽可能的让符号lazy_bind，即第一次访问的时候才会绑定。比如log.c里面调用的printf就是lazy符号。 ➜ xcrun dyldinfo -lazy_bind main lazy binding information (from lazy_bind part of dyld info): segment section address index dylib symbol __DATA __la_symbol_ptr 0x10000C000 0x0000 libSystem _printf 为了支持lazy_bind，首先会在DATA, la_symbol_ptr创建一个指针，这个指针编译期会指向TEXT,stub_helper，第一次调用的时候，会通过dyld_stub_binder把指针绑定到函数实现，下一次调用的时候就不需要再绑定了。 而汇编代码调用printf的时候，直接是调用DATA, la_symbol_ptr指针指向的地址。 Weak Symbol 默认情况下Symbol是strong的，weak symbol在链接的时候行为比较特殊： • strong symbol必须有实现，否则会报错 • 不可以存在两个名称一样的strong symbol • strong symbol可以覆盖weak symbol的实现 应用场景：用weak symbol提供默认实现，外部可以提供strong symbol把实现注入进来，可以用来做依赖注入。 此外还有个概念叫weak linking，这个在做版本兼容的时候很有用：比如一个动态库的某些特性只有iOS 10以上支持，那么这个符号在iOS 9上访问的时候就是NULL的，这种情况就可以用就可以用weak linking。 可以针对单个符号，符号引用加上weak_import即可 extern void demo(void) __attribute__((weak_import)); if (demo) { printf(\"Demo is not implemented\"); }else{ printf(\"Demo is implemented\"); } 实际开发中，更多的场景是整个动态库都被弱链接，对应Xcode中的optional framework：Linked Frameworks and Libraries 设置成optional后，链接的命令会变成-weak_framework Dynamic，对应在dyld bind的时候，符号也会标记为weak import，即允许符号运行时不存在 ➜ Desktop xcrun dyldinfo -bind /Demo.app/Demo bind information: segment section address type addend dylib symbol __DATA __got x100003010 pointer 0 Dynamic _demo (weak import) dlsym & dlopen dlopen/dlsym是底层提供一组API，可以在运行时加载动态库和动态的获取符号： extern NSString * effect_sdk_version(void); 加载动态库并调用C方法 void *handle = dlopen(\"path to framework\", RTLD_LAZY); NSString *(*func)(void) = dlsym(RTLD_DEFAULT,\"effect_sdk_version\"); NSString * text = func(); lldb Xcode的GUI能设置的断点，都可以用lldb的命令行设置 (lldb) breakpoint set -F \"-[UIViewController viewDidAppear:]\" Breakpoint 2: where = UIKitCore`-[UIViewController viewDidAppear:], address = 0x00007fff46b03dab 运行时，还可以用lldb去查询符号相关的信息，常见的case有两个 查看某个符号的定义 (lldb) image lookup -t ViewController 1 match found in /Users/huangwenchen/.../SymbolDemo.app/SymbolDemo: id = {0xffffffff00046811}, name = \"ViewController\", byte-size = 8, decl = ViewController.h:11, compiler_type = \"@interface ViewController : UIViewController @end\" 查看符号的位置 (lldb) image lookup -s ViewController 2 symbols match 'ViewController' in /Users/huangwenchen/.../SymbolDemo.app/SymbolDemo: Address: SymbolDemo[0x0000000100005358] (SymbolDemo.__DATA.__objc_data + 0) Summary: (void *)0x000000010e74c380: ViewController Address: SymbolDemo[0x0000000100005380] (SymbolDemo.__DATA.__objc_data + 40) Summary: (void *)0x00007fff89aec158: NSObject 基于dyld的hook 都知道C函数hook可以用fishhook来实现，但其实dyld内置了符号hook，像malloc history等Xcode分析工具的实现，就是通过dyld hook和malloc/free等函数实现的。 这里通过dyld来hook NSClassFromString，注意dyld hook有个优点是被hook的函数仍然指向原始的实现，所以可以直接调用。 #define DYLD_INTERPOSE(_replacement,_replacee) \\ __attribute__((used)) static struct{\\ const void* replacement;\\ const void* replacee;\\ } _interpose_##_replacee \\ __attribute__ ((section (\"__DATA,__interpose\"))) = {\\ (const void*)(unsigned long)&_replacement,\\ (const void*)(unsigned long)&_replacee\\ }; Class _Nullable hooked_NSClassFromString(NSString *aClassName){ NSLog(@\"hello world\"); return NSClassFromString(aClassName); } DYLD_INTERPOSE(hooked_NSClassFromString, NSClassFromString); 参考资料 The Compiler Mach-O Executables *iOS编译与链接 部分内容参考自公众号小集 By yvan            last update： 2022-09-22 02:14:20 "},"iOS/ClosureAndGeneric.html":{"url":"iOS/ClosureAndGeneric.html","title":"Objective-C的闭包与泛型","keywords":"","body":"回顾Objective-C的闭包与泛型 OC作为编程语言界的80后的，为了能跟新生代的语言有点共同点，也曾让编译器给自己加一些新特性，比如闭包、为空性、泛型等。 1.1 定义 block是Objective-C的闭包实现，它的声明跟定义为： 返回类型 (^名称)(参数类型) = ^返回类型 (参数) { 代码 }; // eg: int (^numberValue)(NSNumber *) = ^int (NSNumber *num) { return num.intValue; }; 执行一个block本质上还是函数调用。编译器编译时会生成一个对应的函数，再把这个函数地址，以及block引用的外部变量用一个结构体存起来，执行的时候以参数的形式传入函数。 1.2 内部实现与变量捕获 通过clang可以将其转换为C++代码，比如这样一个函数，执行clang -rewrite-objc main.m转换为C++为下图. int blockTest() { int number = 1; __block int variation = 0; int (^myBlock)(int) = ^(int param) { ++variation; return number + variation + param; }; return myBlock(1); } 可以看到创建block实际上是实例化了一个结构体 __blockTest_block_impl_0(xxx)，结构体的命名是所在的函数+block_impl+函数里面第几个block. 传入的参数是一个函数指针，一个desc结构体指针。还有两个参数，外部变量number的值，以及外部变量variation的指针。（flags这里忽略，它的作用可以看Block-ABI文档） struct __blockTest_block_impl_0 { struct __block_impl impl; struct __blockTest_block_desc_0* Desc; int number; __Block_byref_variation_0 *variation; // by ref __blockTest_block_impl_0(void *fp, struct __blockTest_block_desc_0 *desc, int _number, __Block_byref_variation_0 *_variation, int flags=0) : number(_number), variation(_variation->__forwarding) { impl.isa = &_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; 函数指针参数是传给impl的FuncPtr的，其余的值结构体自己持有着。 从名字跟作用看impl这个__block_impl结构体就是block本体了。可以理解为一个“基类”，代码定义的block编译器都会生成一个个对应的“派生类”。 struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr; }; 对于number跟variation两个参数，由于block内部不需要对number作修改，所以只是值引用，而对variation变量有作修改，需要加block声明，编译器会用Block_byref_xx的结构体包装这个变量，再以把它的地址作为参数传入block。 1.3 block执行函数 block的构建函数第一个参数是一个函数指针，它是编译器拿block内的代码生成的函数，这个函数的参数是block结构体指针，以及其他block声明的参数。 static int __blockTest_block_func_0(struct __blockTest_block_impl_0 *__cself, int param) { __Block_byref_variation_0 *variation = __cself->variation; // bound by ref int number = __cself->number; // bound by copy ++(variation->__forwarding->variation); return number + (variation->__forwarding->variation) + param; } 1.4 block内存管理 前面的构造函数里面，isa的值编译器是指定了&_NSConcreteStackBlock。这意味着这个block会在进程的虚拟内存空间的栈区创建，函数执行结束堆栈销毁的时候它也会被销毁。 如果这个block是在函数外创建的一个全局block，那编译器会指定isa为&_NSConcreteGlobalBlock。 如果代码对block执行了copy操作，那它会从栈区拷贝到堆区，isa指向&_NSConcreteMallocBlock，由程序自行管理引用计数。 对于声明了__block的变量，前面说编译器会用一个结构体来包装这个变量，比如 struct __Block_byref_variation_0 { void *__isa; __Block_byref_variation_0 *__forwarding; int __flags; int __size; int variation; }; 当block从栈复制到堆时，这些变量也全部被从栈复制到堆上。在栈上的时候Block_byref的__forwarding指向自己，在堆上时则指向堆上的结构体实例。 block构建函数的第二个参数block_desc里面有block_copy跟block_dispose，会负责释放block引用的外部变量。 1.5 链式调用 block的引入给oc带来不少便利，比如可以让一个实例函数通过返回一个block，然后block返回实例本身来达到链式调用的效果。 - (Object *(^)(int num))add { return ^Object *(int num) { self->_result += num; return self; }; } Object *maker = [Object new]; maker.add(2).add(3); 2.1 什么是泛型？ 泛型是把数据的类型参数化，可以编码的时候不指定具体的类型，延后到使用的时候才进行指定。 使用泛型除了可以让代码更简洁减少重复工作外，限定了类型也会让程序更加健壮，提升代码可读性和稳定性。 @interface App : NSObject - (void)translate:(T)obj; @end 比如对于这个App类，创建的时候指定了Button，那么translate的类型T就是Button，传个Object对象编译器会警告。（但也仅仅是警告⚠️而已..） 2.2 协变与逆变 OC的泛型可以指定允许协变还是逆变。 covariant(协变):用于泛型数据强转类型,子类可以转成父类； contravariant(逆变):用于泛型数据强转类型,父类可以转成子类； @interface App : NSObject @end 比如我们加上covariant声明之后，转父类是没有警告的，但是第二行父类想转子类就来警告了。设置contravariant就反过来了。 2.3 其他 指定多个泛型，比如X是输入类型，Y是转换类型，Z是结果类型. @class MyClass; 限定泛型的范围 限定为UIView或者派生类型 @interface App : NSObject @end 限定为实现某个协议的类型 @interface App> : NSObject @end 有别与前面的警告，不按泛型声明的类型来传值是会报错的。 By yvan            last update： 2022-09-22 02:14:20 "},"Flutter/intro.html":{"url":"Flutter/intro.html","title":"Flutter的利与弊(todo)","keywords":"","body":"简介 flutter是一个UI框架，简单点说它是在native端的一个view上绘制界面、处理事件。 我们讨论移动端开发的时候，有几个指标是常常提起的FPS，CPU，内存和GPU性能。 好处 跨平台，省人力(熟练掌握的前提下)， 代价 运行flutter引擎需要额外的内存、cpu资源，包体积. 可能没办法享受到某些原生特性. 难以像原生语言那样充分利用GPU. 不足 flutter仅仅是UI框架，访问硬件、多媒体、存储以及浏览器应用生命周期等能力还是需要native。 横向对比（React Native 资源占用 flutter并不大依赖原生，如果不涉及特定的功能，flutter业务逻辑可以完全不与原生通讯。 相比之下，RN的JS和原生之间的通讯会在序列化和反序列化方面消耗资源（cpu/内存/电量 相比之下，RN的运行没能像flutter那样更好得使用GPU资源。 性能 dart是静态语言，相比动态语言有更高的执行效率。同时Flutter又支持JIT模式, 兼顾开发效率； 动画性能消耗方面，RN应该还是相对不占优。 UI RN依赖native组件，各端有各自的风格；，flutter是自己绘制，全端统一风格。 React Native简述 浏览器展示网页：浏览器按规定实现了一套组件。前端代码用html描述页面有什么组件，css描述组件的样子。浏览器解析html/css之后展示出界面来，解析js代码接收/响应事件，调整界面。 RN跟浏览器很类似，它也有一套UI组件，解析前端代码之后，转发到native层组合/调整页面。 React Native是依靠JS Engine解析执行js代码的（iOS上是JavaScriptCore）. 虽然用JavaScriptCore作为JS的解析引擎，但自己实现了一套通讯机制，没有JavaScriptCore的情况下也可以用webview代替进行js解析。 模块配置表：Objective-C 和 JavaScript 两端都保存了一份配置表，里面标记了所有 Objective-C 暴露给 JavaScript 的模块和方法。这样，无论是哪一方调用另一方的方法，实际上传递的数据只有 ModuleId、MethodId 和 Arguments 这三个元素，它们分别表示类、方法和方法参数，当 Objective-C 接收到这三个值后，就可以通过 runtime 唯一确定要调用的是哪个函数，然后调用这个函数。 OC要告知JS它有什么模块，模块内的方法，参数。JS知道后才可能去调用这些方法。 OC端和JS端分别各有一个bridge，两个bridge都保存了同样一份模块配置表，JS调用OC模块方法时，通过bridge里的配置表把模块方法转为模块ID和方法ID传给OC，OC通过bridge的模块配置表找到对应的方法执行。 js调用native时会把callback函数存起来，同时生成个id传给native，这样native回传时带上id，js端就可以执行对应的callback函数了。 By yvan            last update： 2022-09-22 02:14:20 "},"Flutter/isolate.html":{"url":"Flutter/isolate.html","title":"Flutter基础：异步编程","keywords":"","body":"Dart与单线程模型 CPU核心与线程 核心：可以独立运行程序指令的计算单元。 线程：操作系统进行运算调度的最小单位。 多任务 一个系统，要实现多任务能力，通常会设计Master-Worker模式。一个Master负责任务派发，多个Worker执行。 用多进程实现，主进程是Master，其他进程是Workder; 多线程实现，主线程是Master，子线程是Workder; 两者的区别： 多进程相对安全，进程直接相对独立，互不影响； 多线程相对快捷，线程之间共享内存； 任务类型 通常来说计算机的执行任务分两类：计算密集型，IO密集型 计算密集型: 需要cpu进行大量的计算，比如编解码，计算圆周率；这种情况单核CPU分多线程任务反而增加没必要的切换上下文的时间. IO密集型: 网络、磁盘IO. 不涉及大量的cpu运算. （处于等待IO或者休眠的线程不消耗CPU资源） Dart的异步编程 Dart是单线程，基于任务队列跟事件循环实现了 Future、async、await、completer 异步执行方法，避免执行iO任务的时候阻塞线程。（任务队列又包含Event queue 事件队列和1个 MicroTask queue，每次循环都会优先把MicroTask执行完毕再执行一个EventTask） 对于CPU密集型任务，Dart提供了Isolate以及它的封装方法compute(一种在另一个线程上运行Dart代码的方法)。 通常情况，微任务的使用场景比较少。Flutter 内部也在诸如手势识别、文本输入、滚动视图、保存页面效果等需要高优执行任务的场景用到了微任务。 所以，一般需求下，异步任务我们使用优先级较低的 Event Queue。比如 IO、绘制、定时器等，都是通过事件队列驱动主线程来执行的。 Dart 为 Event Queue 的任务提供了一层封装，叫做 Future。把一个函数体放入 Future 中，就完成了同步任务到异步任务的包装（类似于 iOS 中通过 GCD 将一个任务以同步、异步提交给某个队列）。Future 具备链式调用的能力，可以在异步执行完毕后执行其他任务（函数）。 Future(() => print('task1')); eg: completer: Future sendData(data) { xxx.send(data); // 创建一个completer，先返回一个future _completer = Completer(); return _completer.future; } // 自行决定返回数据的时机 _completer.complete('xxxx'); compute: // 类的静态方法, 或者顶级方法 ( 不包再类里面的方法 function computingIntensive( val ){ // 一些很耗时的计算 return res } /// 正常使用，接受一个方法跟一个参数. var res = await compute( callback , val ); // 创建Future方式 Future() //默认Event队列 Future.microtask() //mocro队列 Future.sync() //立即执行 Future.value() Future.delayed() Future.error() Isolate是分离的运行线程,并且不和主线程的内存堆共享内存.这意味着不能访问主线程中的变量、函数. 没有竞争的可能性所以不需要锁，也就不用担心死锁的问题。通信唯一方式只能是通过Port进行。 使用Isolate也不是没有代价的，创建Isolate，拷贝参数数据都有耗时，额外的内存开销也需要关注。 *LoadBalancer：线程池管理库. 最后, 为什么用单线程模型？ Flutter是UI框架，处理的任务大部分是IO密集型，使用单线程足够. 不涉及线程管理，资源竞争。线程安全，框架实现复杂度大大降低，开发维护都简单. 没有线程切换、加锁开销，简化数据结构和算法的实现，大部分场景下效率更快. By yvan            last update： 2022-09-22 02:14:20 "},"Flutter/render.html":{"url":"Flutter/render.html","title":"Flutter是怎么渲染UI的(todo)","keywords":"","body":"Native侧的载体FlutterViewController: layerClass: CALayer(模拟器)；CAMetalLayer(支持METAL)；CAEAGLLayer(默认) 界面绘制: takeScreenshot函数获取Flutter当前界面的光栅图 TaskRunner: platform(与native通讯,native主线程), ui(dart代码), gpu, io; 无障碍支持: ensureSemanticsEnabled native方法绑定: RegisterNatives方法绑定的几个函数式两端通讯基础(Window_defaultRouteName、Window_scheduleFrame、Window_sendPlatformMessage、Window_respondToPlatformMessage、Window_render、Window_updateSemantics、Window_setIsolateDebugName...) 手势处理: native会把event透传到flutter去派发 ... Flutter的UI绘制流程 用户输入信号(滑动、点击) > 驱动视图更新 > 触发动画进度 > build抽象视图数据 > 布局、绘制、合成（渲染过程的三个步骤），> 光栅化处理成像素填充数据 视图数据结构： Flutter的视图数据抽象分为3部分，分别是Widget、Element、RenderObject Widget: 布局、样式等配置信息 By yvan            last update： 2022-09-22 02:14:20 "},"Flutter/gesture.html":{"url":"Flutter/gesture.html","title":"Flutter与iOS的事件分发","keywords":"","body":"理解Flutter的事件分发 1. 事件 从某种意义上说，一个应用是UI、数据的展示,以及事件响应的集合. 在iOS系统有三类事件：触摸、加速器、远程控制；如果不涉及媒体播放、运动步数等功能，日常开发基本只关注触摸事件； UITouch: 一根手指触摸屏幕，系统就会为其创建一个对应的UITouch对象，多个触摸点对应多个UITouch对象。存储触摸屏幕的时间、位置、力度、所在的window、所在的view等信息。系统判定对应的UITouch对象不会再更新，就会销毁它。 UIEvent: 事件触发后，系统创建UIEvent对象。存储着当前触摸事件的类型以及触发当前触摸事件的UITouch对象集合。 Flutter的事件：PointerEvent（及其子类PointerDownEvent、PointerMoveEvent、PointerCancelEvent、PointerUpEvent），事件对象包含存储触摸屏幕的时间、位置等信息。 2. 事件的产生 iOS: 用户点击屏幕后，系统创建一个触摸事件添加到UIApplication的事件队列，其处理事件的时候把该事件出列，按从顶到下交给屏幕上的window对象，window开始查找firstresponder。（通常是在keyWindow上，找到后也就确定了UITouch.window以及UITouch.view属性属性) Flutter: flutter只是一个运行在原生应用中的UI框架，表现上是原生应用的一个view。因此它的事件来源于原生应用事件，当触发发生在flutter的view上时，它将event信息通过引擎派发到dart层。（dart线程的window.onPointerDataPacket方法） 3. 事件的响应者与响应者链 事件生成后需要有东西接收处理，我们称之为响应者； iOS的ui组件不是全部都能响应事件，只有继承自UIResponder才可以；（UIApplication、UIViewController、UIView、UIButton...） 响应者链：屏幕上的响应者，UIKit框架在创建的时候就通过nextResponder属性反向串起来. Flutter: RenderObject及其子类RenderPointerListener才能传递和响应事件 (它的widget是Listener) *flutter的widget分两类。 1. 需要渲染到屏幕的，继承RenderObjectWidget，由RenderObject持有. 2. 布局、点击、数据监听等不需要展示的包装组件，继承至StatelessWidget或StatefulWidget. 响应者列表： 不同于iOS根据view层级确定的响应链，flutter是在执行hitTest的时候把当前的响应者添加到响应者列表。 4. 事件传递 & 查找第一响应者 一个屏幕上通常会存在多个视图，要确定事件由谁处理，需要在视图之间传递事件进行判断； 事件传递的目的是为了确定响应者（firstResponsder） 在iOS，视图通过执行hitTest方法判断自身或子视图是否为firstResponsder, 过程中父视图会通过这个方法传递事件到子视图。 - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event { // 判断用户交互 || 隐藏 || 透明度 if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha = 0; i--) { UIView *childView = self.subviews[I]; // 把触摸点的坐标转换到子视图的坐标系统下 CGPoint convertedPoint = [self convertPoint:point toView:childView]; // 事件传递：子视图hitTest找第一响应者 UIView *fitView = [childView hitTest:convertedPoint withEvent:event]; if (fitView) { // 如果最终找到了就返回 return fitView; } } // 没有子视图 || 它的子视图都不能响应事件 || 触摸的点都不在它的子视图身上时 // 当前view作为第一响应者 return self; } Flutter: 也是类似的由RenderObject通过hitTest方法传递事件。根视图RenderView的hitTest方法开始，倒序(从顶部开始)添加到响应数组，数组的第一个就是firstRespondder； 5. 事件分发与响应 应用通过传递事件确定第一响应者后，将事件派发给第一响应者，然后沿着响应链传递处理事件。 iOS: touch对象收集到view后，UIApplication、window通过sendEvent方法把事件发送给它处理， view响应事件，具体表现为touchesBegan/moved/canceled/ended的调用； 这四个方法的默认实现是调用nextResponser的几个touch事件. Flutter: Listener的onPointerDown、onPointerMove、onPointerUp、onPointerCancel方法响应； 区别于iOS沿着响应链依次判断执行，flutter是遍历响应者数组的每一个HitTestEntry对象都执行handleEvent，因此数组第一个会先执行。 6 手势(iOS) 手势作为特殊的事件响应者来说明； （手势的存在，大大丰富了用户与设备的交互blabla..） iOS: UIGestureRecognizer不在响应者链里，也不是UIResponder的子类。它需要与view绑定，并观察事件派发的过程。与view的四个响应函数某种程度上是竞争关系。 @property (nonatomic) BOOL cancelsTouchesInView; @property (nonatomic) BOOL delaysTouchesBegan; - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch; cancelsTouchesInView：默认YES，手势识别成功取消view的事件响应；设置NO,那么手势跟view都能响应； delaysTouchesBegan：默认NO，系统直接调用view的touchBegan，手势识别后调用取消；如果YES，那么手势识别后会取消这个delay，结果是view连Began都没机会响应 方法gestureRecognizer:shouldReceiveTouch:：用于判定手势是否响应这个Touch事件 delaysTouchesEnded (默认为YES)：当手势识别器在识别手势时，对于UITouchPhaseEnded阶段的touch会延迟发送给hit-test view,在手势识别成功后,发送给hit-test view cancel消息，手势识别失败时，发送原来的end消息。 如果view实现了touch事件处理，同时有手势。当手势判定开始触发的时候，view的touch事件会被cancel（表现为执行cancel，且不执行end），如果是tap手势，那么连touchBegin都不会执行； 那是因为window在将触摸事件传递给第一响应者hitTested view之前，会优先把触摸事件传递给手势识别器。如果手势识别器成功识别了该触摸事件，那么手势识别器就拥有了该触摸事件的响应权。firstResponder本身则不会被调用响应方法； UITouch.gestureRecognizers里存储的是响应者链上所有响应者的手势，他们都有比UIResponder更高的事件响应优先级。 6.1 多个Gesture Recognizer view上可以绑定多个Gesture Recognizer, 触摸事件会无序优先传给gesture recognizer，没有手势识别成功则发送给hit-test的view。 单击+双击手势，默认情况下点击一次两个手势都能识别到；如果想双击的时候，单击事件不触发，可以要求某个手势失败后才进行识别。（会有微小的延迟） [singleTapGesture requireGestureRecognizerToFail:doubleTapGesture]; 精准控制是否响应某个事件/序列 UIGestureRecognizerDelegate\u000b UIGestureRecognizer：canPreventGestureRecognizer.. 允许多个手势识别器共同识别, 默认no UIGestureRecognizerDelegate:shouldRecognizeSimultaneouslyWithGestureRecognizer 举个例子：要记录window上的触摸事件，可以加一个手势，但是又不想影响其他手势处理，可以这里返回yes来实现。 UIScrollView控制触摸事件由子视图还是本身可以用它的以下方法 – touchesShouldBegin:withEvent:inContentView: – touchesShouldCancelInContentView: canCancelContentTouches delaysContentTouches 6.2 Gesture与view/button 假设vc上有一个button，一个子view，三者都添加了tapGesture ● button点击: 触发tap，自身touch事件不执行（因为按钮响应是delay触发的，手势识别后可以cancel按钮的响应） ● 点view或vc上的view: view先执行touchBegan，然后手势识别成功执行，然后view执行touchCancel（delayTouchBegan的话，则view不会执行touch） ● 删除button的手势，点击按钮: 只执行按钮事件，nextRep的vc手势不触发 ● button/view拖动: 当底下vc的拖动事件触发的时候，会执行按钮/view的cancel ● 子view跟按钮的手势互不影响，因为他们不是一个响应链 总结： ● 一般来说view跟gesture是独立传递事件的，view的事件默认从第一响应者开始沿着响应链处理。如果touch函数不调用super touchBegan，那只有第一响应者处理； ● 响应链上的手势，没有特殊设置的话，会按响应链先后顺序判定。只有一个手势响应。 ● 当响应链上有手势识别成功，会执行view的touchCancel，包括子view。 ● 特殊的，按钮的点击会消化掉事件，不会沿响应链传递，也就不会被父视图的手势取消；但拖动事件是会传递的，跟普通view表现一致。 7 手势(Flutter) Flutter: flutter的手势本质上是Listener的包装，是一种特殊的响应者。 特殊之处在于，普通响应者handleEvent是执行具体地响应逻辑。 而手势的handleEvent是将自身添加到手势竞争管理类GestureBinding.gestureArena，等判定胜出了才会真正执行响应逻辑。 当有一个手势判定通过执行acceptGesture，其他手势会执行 rejectGesture。 由于要等待GestureBinding判定手势是否胜出，因此手势的响应总会晚于其他Listener。 多手势竞争： 在Down事件中，所有的竞争者被添加到_GestureArena进行竞争，最后回到GestureBinding关闭竞技场。这时如果区域中只有一个RawGestureDetector，则在Down事件阶段这个控件直接获得胜利，进行acceptGesture，但这时并不会触发onTap,等到Up事件之后,触发onTapUp,后执行onTap。 如果只有一个手势类，那肯定是交给这个对象处理手势。但如果有多个手势识别类，在down事件阶段是无法判断这是一次什么样的行为，可能是点击（后续Up事件），可能是滑动（后续Move事件），所以Down事件阶段主要作用是收集手势竞争对象。 如果区域内有多个RawGestureDetector，在Down 事件时竞技场 close 不会竞出胜利者。Up 事件的时候，竞技场 sweep 选取排在第一个位置的为胜利者进行acceptGesture。以上过程只是以点击为例。如果是滑动，肯定在Move阶段就产生了胜利者，不会等到Up事件。 GestureBindg会从调用hitTest方法，从负责绘制的树根节点出发，递归收集所有区域范围内包含这个点击坐标的view得到一个hitTestResult集合，在树层级层级越深的view会被位置越靠前。在有了这个集合之后，遍历调用每一个对象的handleEvent，一般回调到RawGestureDetector中，会将自己添加到竞技场中。遍历完后如果竞技场只有一个参与者，则这个参与者直接获得胜利;如果有多个参与者，则暂时不会决出胜负。所以Case1中的out控件在down事件时竞争成功，并且回调onTapDown方法，但这是还不能认为onTap；而Case2中，参与竞争的有三个对象:out、listView、ges2，所以在down事件时无法选出胜者。 Up事件会调用GestureArenaManager.sweep ，如果没有已经胜利的竞争者，则在这个阶段会强行选择hitresult中的第一位的竞争者为胜利，并且回调acceptGesture回调onTapUp和OnTap方法。 拦截事件的Widget: IgnorePointer或AbsorbPointer，它俩分别有一个bool值属性叫ignoring、absorbing用来决定是否拦截事件 7 实践与应用 应用1: flutter内嵌native view 在flutter早期版本，很多功能都不完善（比如webview连cookie设置都不支持），需要原生能力协助实现某些功能，具体表现为flutter页面的某个部分展示native视图。而官方提供的PlatformView早期也存在一些问题，碰到需要跟native进行特殊通讯的时候不大方便(比如与webview的jsbridge交互) 由于flutter在native层只是一个view，我们可以在它的上面放置其他的view，然后在最顶层加一个透明的window/view，来拦截hittest。自行实现视图的展示/隐藏，事件派发，从而实现flutter页面内嵌native view。 拦截hittest: 当需要底部的flutter层需要被点击的时候，顶层的view的hittest返回自己（作第一响应者）。否则不做处理，事件按原定流程处理。 自定义事件派发：重载keyWindow的sendEvent事件，根据事件类型调用flutterVc的touchBegin/Move/cancel/end事件。 注：flutterVc可以以子vc的形式添加到当前vc上管理，并且设置不可点击（保证flutter事件均由我们自行传递） 应用2: flutter无埋点事件监控 flutter分发事件的过程、响应者、widget、event都在各种的阶段处理各自的事情，没有一个时机可以同时获取到几个角色；而且flutter并不支持AOP，没办法像iOS那样方便地hook点击处理函数。 因此要实现无埋点事件监控，得通过重载相关系统类的方式实现； 需要重载的关键方法： // GestureBinding的派发事件方法. // 1. 把event跟hitTestResult 关联起来. void dispatchEvent(PointerEvent event, HitTestResult? hitTestResult) {} // GestureArenaManager的添加竞争者方法. // 2. 第一步hitTestResult的target，跟menber关联起来. GestureArenaEntry add(int pointer, GestureArenaMember member) {} // GestureArenaMember的接收/处理手势方法. // 3. 记录/上报该手势以及对应的，收集/查找到的，事件/widget信息. void acceptGesture(int pointer) {} *为了收集具体地点击信息，还需要重载某些类，以及一些element树的查找过滤. 详细实现: flutter_monitor By yvan            last update： 2022-09-22 02:14:20 "},"Flutter/dynamic.html":{"url":"Flutter/dynamic.html","title":"Flutter动态化","keywords":"","body":"[TOC] Flutter与动态化 前言 编程语言要达到可运行的目的需要经过编译，一般地来说，编译模式分为两类：JIT 和 AOT。 JIT全称 Just In Time(即时编译），典型的例子就是 v8，它可以即时编译并运行 JavaScript。所以你只需要输入源代码字符串，v8就可以帮你编译并运行代码。通常来说，支持 JIT的语言一般能够支持自省函数（eval），在运行时动态地执行代码。 AOT全称 Ahead Of Time（事前编译），典型的例子就是 C/C++，LLVM或 GCC通过编译并生成 C/C++的二进制代码，然后这些二进制通过用户安装并取得执行权限后才可以通过进程加载执行。 Flutter的编译模式 Script：同 Dart Script模式一致，虽然 Flutter支持，但暂未看到使用，毕竟影响启动速度。 Script Snapshot：同 Dart Script Snapshot一致，同样支持但未使用，Flutter有大量的视图渲染逻辑，纯 JIT模式影响执行速度。 Kernel Snapshot：Dart的 bytecode 模式，与 Application Snapshot不同，bytecode模式是不区分架构的。 Kernel Snapshot在 Flutter项目内也叫 Core Snapshot。bytecode模式可以归类为 AOT编译。 Core JIT：Dart的一种二进制模式，将指令代码和 heap数据打包成文件，然后在 vm和 isolate启动时载入，直接标记内存可执行，可以说这是一种 AOT模式。Core JIT也被叫做 AOTBlob AOT Assembly: 即 Dart的 AOT模式。直接生成汇编源代码文件，由各平台自行汇编。 Flutter的核心还是跨平台而不是动态化，但这两者都是目前业界的诉求，因此才会有那么多的动态化方案产生。 Flutter框架的开发语言是Dart，实现动态化需要关注的是Dart语言的编译、运行过程. AST: 编译器把开发编写的业务代码跟FlutterSDK解析为一个抽象语法树（内存对象） dill、bin: AST对象序列化存到磁盘的文件类型; eg:app.dill，或者Debug阶段的产物(kernel_blob.bin) Dart Kernel: AST文件的数据格式，能够被Dart VM解释执行；也是dart2js或其他转换的中间语言. IL: Intermediate Language, 要生成AOT产物，编译器会加载dill文件，编译成类似字节码的中间语言。 DartVM Introduction to Dart VM Dart VM 是一个执行 Dart 语言的组件集合: 1. 运行系统（对象模型、垃圾收集、快照） 2. native代码核心库 3. 开发体验优化组件（debug调试、性能分析、热重装） 4. JIT、AOT编译管道 5. 解释器 6. 指令模拟器 7. ... Dart VM怎么执行Dart代码 1. 从源码执行或者通过 JIT 执行内核二进制文件(Kernel binary) 2. 从快照中恢复。（AOT快照或者AppJIT快照） 3. 在VM上执行的 Dart 代码，都依赖 isolate（控制线程跟独占的堆内存等资源组合） 4. 单线程模型，是指同一时刻，一个线程只能进入一个isolate。相同的系统线程可以首先进入一个 isolate，执行 Dart 代码，然后退出这个 isolate 在进入另外一个 isolate。 isolate 除了会关联一个突变线程，同时也会被关联到许多辅助线程，比如： 一个后台的 JIT 编译线程； 多个垃圾清理线程； 多个并发的垃圾标记线程。 自从 Dart 2 版本之后，VM 已经没有了直接从源代码执行 Dart 的功能，取而代之的是，VM 只能执行那些由内核抽象语法树（Kernel ASTs）序列化成的内核二进制文件（Kernel binaries）（又被称作 dill files）。而将 Dart 源码翻译成内核抽象语法树的任务则交给了由 Dart 编写的通用前端common front-end (CFE）,这个工具被不同的 Dart 模块所使用（举个例子：虚拟机（VM），dart2js，Dart Dev Compiler）。 为了保留直接从独立源码直接执行 Dart 的便利性，专门还提供了一个辅助 isolate ，叫做 kernel service ，专门用来处理 Dart 源码编译成内核可执行文件的过程。之后 VM 就能直接执行生成的内核二进制文件了。 动态法方案 Flutter框架的三颗树 WidgetTree:Widget 里面存储了一个视图的配置信息，可以高效的创建（build）和销毁 Element 是分离 WidgetTree 和真正的渲染对象的中间层， WidgetTree 用来描述对应的Element 属性 RenderObject 来执行 Diff， Hit Test 布局、绘制 1.自定义模板代码 借鉴RN的思路，选一门可以在客户端执行的解析行语言，自定义一套模板跟目标语言的UI组件一一对应。比如采用js语言，再用json格式来定义模板语言。 基于这个思路的实现： 58的fair 优点：从RN的发展来看，这个方向是可取的. 缺点：代码执行至少多一层解析。另外，都是用前端生态了，为何不直接用RN？？ 2.替换开发语言 mxflutter 代替Dart生成Widget树的职责。 用JS完整实现一遍Flutter SDK内置在工程中，JSCore或V8引擎运行编写的业务JS代码，生成一个WidgetTree，并序列化为json文件。Dart端加载该文件，转换为真正的Widget-Tree并进行渲染。 问题点： TS/JS->JSWidget->json->FlutterWidget链路较长，问题定位比较困难；生成WidgetTree效率就相对要低，再加上数据及事件通知需要反复经JS-Dart通道进行通讯等因素，都会导致UI渲染效率低下。 3. 基于AST导出DSL 美团的MTFlutter: Flap 原理是把Dart代码用Analyzer工具转为AST，简化保存为json文件。 终端有一个解释器，递归访问json中的节点，然后将json中的字符串映射到Dart代码中的函数，然后调用函数的万能方法Function.apply(),完成对应代码指令的执行。 eg: 我们看\"#FontWeight.normal\"这个节点，从字符串到函数的映射就是{\"#FontWeight.normal\":()=>FontWeight.normal}。在访问\"#FontWeight.normal\"命名的这个节点时，只需调用:()=>FontWeight.normal这个函数的Apply()方法即可创建出对应的Dart对象。当然完整的实现还有更复杂的自定义类的解释要支持继承、混入等语法， 变量要支持作用域的管理等。 优点： 前两个思路都是比较表层的动态化，对Dart开发有很大的影响 (动态化跟目标代码语言不同)。而从AST层往下的动态化则可以让上层Dart开发者在编码阶段无感知。 问题点： 由于AST未经过编译，每个代码文件生成的AST中都只包含当前文件的信息，缺乏代码精确的数据类型、代码上下文及依赖关系等关键信息。因此在解释过程中经常会遇到类型推断上的困难，在处理比较复杂的继承关系或隐式依赖时，因缺乏对应信息而找不到对应的符号以完成执行。MTFlutter解决这一问题的方法是限制Dart语法的使用。 4. 基于Dill文件 由于Analyzer解析Dart代码得到AST中信息不够完备，导致很多正常的Flutter代码写法无法顺利解释执行。尤其是如果项目要依赖一些Flutter社区提供的有比较复杂写法的一些第三方库，更是举步维艰。为了解决这一问题，将动态化产物调整为使用Kernel Binary。 UC的Aion 、手Q的 DNFlutter. 需要动态化的代码编译为Dill文件后，通过在AOT模式下增加对KBC 解释器的支持，实现KBC与AOT在混合模式下运行。，直接用DartVM将这部分解释执行； 问题点： Flutter新版本已经裁剪掉了KBC解释器代码，为适应Flutter后续版本的升级和变化，需要自行对KBC解释器代码进行维护，维护的成本随着Flutter版本的不断升级也将不断升高。而且内置一个解释器也增加不少包体积。 5. 基于IL指令集 基于Dart的中间语言(IL, Intermediate Language)，参考并定制Dart VM本身的C层实现，在Dart层设计了一套指令集和栈帧式虚拟机，在运行时，将IL转化为指令集逐条执行。 实现包含两个关键要素： ① 生成IL Flutter&Dart工具链：编译Flutter&Dart源码，得到中间语言IL IL二进制格式的读写：将IL输出为二进制格式，提升读取效率 ② 执行IL 指令集：作为IL的内存数据表示 栈帧式虚拟机：执行指令，对栈元素进行精准控制 代理生成器：自动生成Flutter&Dart核心库的代理实现 6. 基于so文件 Android端的产物是so文件，是可以直接替换的。方案仅限于安卓系统。 换一个角度看动态化方案（摘自MTFlutter文章） a. 产物替换 对应上诉的6 选型中首先考虑到的是下发产物替换，官方在也曾经推出了 Code Push 方案，甚至可以支持 Diff 差量下载，但是在 2019 年 4 月被叫停。 简而言之，就是官方对动态化后的性能没有自信，并且对安全性有所顾虑。之前，官方提供方案的局限性也十分明显。比如对 Native-Flutter 混合 App 支持不友好，并且无法进行灰度等业务定制操作，所以不能满足通用性和高性能的核心目标。 b. AOT 搭载 JIT Flutter 在 Release 模式下构建的是 AOT 编译产物，iOS 是 AOT Assembly，Android 默认 AOTBlob。 同时 Flutter 也支持 JIT Release 模式，可以动态加载 Kernel snapshot 或 App-JIT snapshot。如果在 AOT 上支持 JIT，就可以实现动态化能力。但问题在于，AOT 依赖的 Dart VM 和 JIT 并不一样，AOT 需要一个编译后的 “Dart VM”（更准确地说是 Precompiled Runtime），JIT 依赖的是 Dart VM（一个虚拟机，提供语言执行环境）；并且 JIT Release 并不支持 iOS 设备，构建的应用也不能在 AppStore 上发布。 实现此方案需要抽离一份 DartVM 独立编译，再以动态库的形式引入项目。通过初步测试，发现会增大包体积 20MB+，这超过了 MTFlutter 之前做 Flutter 包体积优化的总和。进一步让 Flutter 包体积成为推广与接入业务方的巨大阻碍，不满足我们对适用性的要求。 c. 动态生产 DSL Native 侧本身具备 JS 动态执行环境，利用这个执行环境动态生成包含页面和逻辑事件绑定 DSL，进而解析为 Flutter 页面或组件，也可以实现动态化诉求。技术思路接近 RN，但与其不同的是利用 Flutter 渲染引擎和框架。这种先将代码执行起来再获取 DSL 的手段，我们简称为动态生产 DSL。 此方案可以很好地支持逻辑动态化，但弊端也比较明显。首先要对齐 Flutter 框架，JS 侧的开发量很大且开发体验受损。另外，对 JS 的依赖偏重，构建的 JS 框架本身解释执行有一定开销，对于页面逻辑与事件在运行中需要频繁地进行 Flutter 与 JS 的跨平台通信，同样也会产生一定开销。这不能满足 MTFlutter 团队对高性能的诉求。更严重的是，此方案对开发同学的开发习惯并不友好，将 Dart 改为 JS，现有的 Flutter 开发工具无法直接使用，这与低成本诉求背道而驰。 d. 静态生产 DSL 前面说 “将代码执行起来再获取 DSL 的手段，我们简称为动态生产 DSL”，那么代码不执行直接转换 DSL，就称为静态生产 DSL 方案。 静态生产的特点是抹平了平台差异，因为 input 是 Dart source 与平台无关，直接将 Dart source 内的完整信息通过一层转换器转换到 DSL，然后通过 Native 和 Dart 的静态映射和基础的逻辑支持环境，使得其可以在纯 Dart 的环境下渲染与交互。 在具体实现上，可以利用 Dart-lang 官方提供的 Analyzer 分析库（该工具在 Dartfmt、Dart Doc、Dart Analyzer Server 中都有使用）构建 DSL。该库提供了一组 API 能对 Dart source 进行分析，按照文件粒度生成 AST 对象。AST 对象用整齐的数据结构包含了 Dart 文件的所有信息，利用这些信息可以便捷地生成所需的 DSL。所有的这个分析 + 转换的过程全部在线下进行。接下来， DSL-JSON 以 Zip 的形式下发，Flutter 的 AOT 侧以此为数据源，完成整个 Flutter 项目的渲染与交互。 这种方案，一来可以保持 Flutter/Dart 的开发体验，也没有平台差异，逻辑动态化依赖静态映射和基础逻辑支持，而非 JScore，有效地避免了性能上的开销。 推荐方案 阿里的Kraken(微信的liteapp) 与 手Q的 DNFlutter Kraken实现了一套兼容W3C规范的DOM API，上层业务逻辑最终通过统一的DOM API，经过Bridge层完成js-dart的通信，上层的指令传递到Flutter端，实现对Flutter端的调用。在Flutter端直接使用Render Object进行绘制后直接挂载到RenderView上进行渲染。 在跨端通信上，采用基于dart:ffi的方案解决效率问题。 整个架构设计依然是类 RN 方案，只是 Native 渲染层从系统平台侧切换成了 Flutter Engine 自绘，以解决跨端渲染不一致的问题，Flutter 自身的问题依然存在（如内存占用过大、包增量、图片内存问题等）。同时通过 Flutter Engine 提供的 FFI 通信接口进行 JSCore 与 Flutter 之间的通信，缓解了类 RN 方案中 JSBridge 通信效率低导致的排队性能瓶颈。 手Q的 DNFlutter 基于Kernel Binary，自己实现解释器（Flutter代码的中间编译产物dill文件的数据格式，dill文件中其实也包含一个AST，叫做Kernel AST，并且系统提供了一个名为Kernel的库，支持对Kernel AST中节点的访问，并且支持懒加载）。 Kernel AST最大的优势是其经过了编译过程中的类型推断（TFA），因此节点中包含精确的数据类型信息。dill文件中也包含类的继承、混入经编译处理后的完整信息，在信息上基本是完备的。这就为支持完整的Flutter代码的写法提供了基础和前提。本方案实现的解释器在解释能力上有了很大的加强，比较复杂的继承和混入写法的解释也可以支持。通过扫描Kernel AST，可以对动态化代码依赖的符号进行精确的定位，再借助自动化脚本，就能对项目以来的镜像代码进行生成，并保证符号的完备性。 在性能上，由于Kernel Binary是一种二进制格式，在格式上更为紧凑，加载和访问的速度相比json格式也有很大的提高。由于支持懒加载，AST加载及访问的耗时不再随代码量的增加而线性上升，因此可以支持更复杂的业务进行动态化。 DNFlutter整体流程 将 Dart 业务源码通过 DNFlutter 的 flutter_ast_gen.sh 脚本生成 dill，app.dill 包括系统 library, 再通过裁剪生成 ast.zip，目的是为了仅保留业务代码部分，以减少下发的包大小 接着通过 run_buildin_builder.sh 生成业务代码的系统依赖符号，实现解释器对原生类的转调，检查是否会有未内置的 buildin。注意，目前 buildin 只能内置在宿主工程，随宿主工程一起编译，业务代码变只能依赖已有的 buildin，因为 AOT 编译后，不被引用的符号会被裁减了，所以得加个 build_in 保证符号被引用，这样 AST 运行时才有这些符号。 宿主工程在 AOT 侧通过 DNFlutter 提供的 AST Runtiime 解释执行 AST。在 buildin 不变情况下，通过在线下发 AST 资源实现动态化。 结尾：动态化都避免不了一个问题：错误定位都比较困难；语法支持不完善；Flutter版本更新后难以跟上。 传统动态化 分为基于Webview的动态化比如H5或者小程序，跟基于Native渲染的方案。 1. 基于Webview 对于一、二阶段的耗时可以做一些优化； H5: 常见的比如12306，通过Webview预热、并发网络请求、离线包等方案进行性能优化； 小程序：代码及资源预下载、UI渲染与业务逻辑各自一个独立线程等性能优化措施； 但第三阶段的渲染耗时跟事件响应的优化则难以进行。 Webview的渲染流程Html->DomTree ->RenderTree->RenderLayer+栅格化->合成->GPU渲染。 相比比Native的View->Layout->RenderNode->合成->GPU渲染要多出好几步，并且渲染管线不支持批量处理，因此在性能上优化空间有限，遇到UI频繁更新的场景，性能下降尤为明显。（批量渲染是通过减少CPU向GPU发送渲染命令的次数，以及减少GPU切换渲染状态的次数） 2. 基于Native 为了上诉第三阶段解决渲染问题，ReactNative这类框架改用JSCore或V8引擎解释执行代码，并构建Virtual DOM Tree来合并界面变动，最终映射为Native组件进行渲染。 这样解决了渲染的效率问题，但是由于依赖平台UI，灵活性受到限制；而且也存在加载、跨端通讯、编解码、等耗时问题。 By yvan            last update： 2022-09-22 02:14:20 "},"Flutter/jrs.html":{"url":"Flutter/jrs.html","title":"配置化管理Api接口代码","keywords":"","body":"配置化管理Api接口代码 在app中，业务代码跟网络库之间通常会有请求接口这么一层。随着版本迭代，接口数量增加，对应的请求函数也会增加。实现配置化管理，用脚本生成这部分代码，能够节省编写请求代码跟数据模型类的时间，同时也能避免请求函数、模型类里耦合业务逻辑的情况，保证数据层的纯净。 Json & Model 模型类用于映射接口字段，通常来说只包含接口参数跟两个json的相互转换函数。模型类的自动生成各种语言都有很好第三方的实现，这里不赘述。 请求接口 简化一下请求接口：使用api命名，参数映射为一个对象. 函数内指定api路径，调用方只负责参数即可. 域名.接口名((参数对象) {赋值}) 请求接口配置文件 配置文件包含三部分 1是baseURL 2是接口列表 3是自定义的数据类型 *其中接口列表的字段包括：CGI，发送方法，参数，回包数据。 rspName字段是可选的，用于指定回包对象的名称。 models列表用于自定义数据类型声明。声明之后在配置里面通过@符号使用. 最终生成的接口类： 具体实现代码： json_request By yvan            last update： 2022-09-22 02:14:20 "},"Flutter/startUp.html":{"url":"Flutter/startUp.html","title":"0到1准备一个Flutter App(todo)","keywords":"","body":"Flutter应用从0到1 背景：从0开始开发一个云盘应用. 编码规范. Flutter的Linter规则记录在工程一级目录的analysis_options.yaml文件中。 应用的基础能力 页面跳转 使用官方go_router库管理 通讯能力：与webview交换信息，与服务器交换信息，与原生层交换信息。 与webview通讯: 使用官方的webview_flutter，有执行js接口，有channel提供接口给js调用。（还没支持回复js消息，可以参考jsbridge自行扩展消息callback能力.） 与native通讯: 通常来说有ffi跟methodChannel两类，ffi有性能优势，但使用起来没有channel友好。 官方提供的pigeon能自动生成methodchannel代码，但是每个接口都会生成一大串代码。如果对代码量比较在意还是建议使用一个methodchannel，根据参数区分不同的通讯需求. 与服务器通讯：使用dio, 的确是个很优秀的网络库，官方也推荐. 代码生成 Flutter图片资源的调用代码，可以用一些第三方库(或自行实现)自动生成, 比如`flutter_gen_runner`. 网络请求接口函数也是能够api参数自动生成，`json_request` TODO 腾讯文档的问题？ view数据分离. 统一路径管理. (卡顿)计算管理. 人力问题 > 技术问题（） 旧框架的问题 细节 数据连通 By yvan            last update： 2022-09-22 02:14:20 "},"CleanCoder/iOS-Unit-Testing.html":{"url":"CleanCoder/iOS-Unit-Testing.html","title":"iOS单元测试","keywords":"","body":"1. 什么是单元测试 在面向对象语言中，一个单元就是一个方法. 通过测试代码对一个方法进行正确性验证就叫单元测试 google对测试的分类： 表头 小型测试 中型测试 大型测试 测试类型 单元测试 逻辑层测试 UI测试/接口测试 测试环境 mock mock/真实 真实 网络访问 否 localhost 是 测试金字塔对测试的分类：最底层是单元测试，然后是业务逻辑测试，最后是端到端的测试（GUI或CLI）。—《Succeeding With Agile》 单元测试依赖少，耗时底，解决问题成本低。 大型集成测试是在真实环境测试的，更能保证整个应用的可靠性，但这个阶段解决问题成本相对比较高。 小型测试是是大型测试的根基，各种测试阶段是相辅相成，而非互斥。 为什么要写单元测试？ 提前发现代码问题：边界条件难以手工验证，代码可能有逻辑错误 保证方法的正确性：为重构打好基础 优化代码设计 2. iOS单元测试框架使用 (XCTest + OCMock) XCTest相关tips 单测类继承自XCTestCase类 单测方法以test开头 setUp/tearDown有类方法与实例方法 单测文件命名与目录建议仿照业务代码 单测执行顺序与编码前后无关，每个单测都是相互独立的. Xcode集成，简单易用，学习成本低 支持同步/异步流程测试 支持单元测试，性能测试，UI测试 提供丰富的Assert方法 添加单元测试 创建项目点的时候，勾选添加单元测试. 手动创建单元测试target，添加单元测试文件. 常见的断言 - XCTFail - XCTAssert - XCTAssertTrue - XCTAssertEqual - XCTAssertEqualObjects - XCTAssertEqualWithAccuracy - XCTAssertNil - XCTAssertNotNil - XCTAssertThrows XCTest demo // 被测方法 + (NSString *)descForCount:(NSInteger)count; // 单元测试 - (void) testDescForCount { // arragne NSInteger count = 0; // action NSString *desc = [CDataUtil descForCount:count]; // assert XCTAssertEqualObjects(desc, @\"0\"); } OCMock 支持stub并添加自定义行为 支持mock class/protocol/observer 支持参数验证、延迟验证 // 对于依赖网络或者第三方接口的函数，可以用扩展方法把它暴露出来，然后用mock替换掉. @interface CDataUtil () + (NSInteger)countThreshold; @end @interface CDataUtilTest2: XCTestCase @property(nonatomic, strong) id mock; @end @implementation CDataUtilTest2 - (void)setUp { _mock = OCMClassMock([CDataUtil class]); OCMStub([_mock countThreshold]).andReturn(0); } - (void)tearDown { [_mock stopMocking]; } - (void)testDescForCount { NSInteger count = 100; NSString *desc = [CDataUtil descForCount2:count]; XCTAssertEqualObjects(desc, @\"100\"); } @end *这里也可以把内部的依赖提取出来作为参数传入，这样也就不需要mock了. 3. 单元测试用例设计 步骤 Arrange：准备好所需要的外部环境，数据、mock等. Action：调用需要测试的方法或流程 Assert：判断结果是否符合预期 经验 运行 先跑起来看看环境是否正常 正反面测试 对于数字的参数，正面可以是正数，负面则为负数 特性测试 临界值 完善代码覆盖率 编辑Edit scheme, 勾选Code Coverage跟target，构建结构就回展示详细的代码覆盖率。以及在Xcode编辑页面有右上角勾选Code Coverage就可以看到被覆盖的绿色部分跟没有被覆盖的红色部分. 基本原则 基于意图而不是实现 简单、清晰、易懂 (包括函数名，函数体) 避免引入条件判断，循环等 测试用例完备而不重复 使用Assert进行验证 4. 单元测试案例分析 UI代码写单元测试？: 纯UI代码不需要写单元测试 分离数据与ui代码，对数据部分编写单元测试 复杂代码需要进行合理的拆分. 通过单测优化代码架构 异步代码写单元测试？: 确定是否需要验证异步逻辑 单元测试是同步执行的，对于异步代码需要使用Expectation，并设置合理的超时时间，到达时间waitForExpectations会触发超时错误. // 有效的单元测试，通过XCTestExpectation验证异步代码 - (void)testAsyncFetchCount2 { // 添加预期 XCTestExpectation *expect = [self expectationWithDescription:@\"asyncFetchCount\"]; [CDemoUtil asyncFetchCountCompletion:^(NSInteger count) { XCTAssertEqual(count, 0); // 通知执行完成 [expect fulfill]; }]; // 开始等待并设置超时时间 [self waitForExpectations:@[expect] timeout:1]; } OCMock常用功能 测试方法是否执行/未执行：使用OCMExpect/OCMReject添加预期，然后执行代码，最后用OCMVerifyAll验证预期. 测试方法的参数：使用OCMArg.checkWithBlock对参数进行验证. 测试方法的执行顺序：setExpectationOrderMatter：YES, 之后会按照添加预期的顺序，验证执行顺序 忽略参数类型：OCMArg.any（自定义类型），ignoringNonObjectArgs（基本类型） 验证异步逻辑：OCMVerifyAllWithDelay设置超时时间 提升代码的可测性 明确测试用例是否需要Mock 思考从diam设计上能否避免使用Mock 使用依赖注入等方法提升代码的可测试性：如果代码需要大量的mock才能写好单测，那么这块代码的外部依赖是比较多的。在使用mock之前应该相信是不是可以优化代码结构来提升代码的可测试性。 以前面的countThreshold为例： ```objc // 将threshold作为参数传入，避免内部产生依赖 (NSString *)descForCount2:(NSInteger)count withThreshold:(NSInteger)threshold; ``` 小结 逻辑层代码都需要单测 保证没问题可以不写，但除了文档一定要补充单元测试 重构之前先补充单元测试 发现不好写单测的情况及时优化diam结构 合理使用Mock辅助编写单元测试 5. 单元测试自动化 做好自动化才能更好的发挥单元测试的优势, 真正做到通过单元测试来保证代码质量. xcodebuild提供了test命令，执行完毕之后会生成结果文件以及覆盖率文件，通过解析结果文件可以获取单测的成功数、失败数、覆盖率等详细数据。 以下是搭建自动化流程需要关注的点： 单元测试用例个数、失败个数、执行时长监控 全量代码覆盖率、各模块代码覆盖率监控 MR增量代码覆盖率检测 版本增量代码覆盖率检测 个人增量代码覆盖率检测 # 执行单元测试 xcodebuild test \\ -workspace Xxx.xcworkspace (or xx.project file) \\ -scheme Xxx \\ -derivedDataPath \"build/\" \\ -destination \"platform=XXX,OS=XX.X,name=xx\" \\ -resultBundlePath \"result/\" \\ -resultBundleVersion x # 获取覆盖率文件 xcrun xccov view --report --json path/to/xcresult 单元测试自动化监控小结 用例数合代码覆盖率是单元测试水平的重要体现. 不应盲目追求用例数和代码覆盖率，单测的目的是发现问题保证质量. 有数据度量才能推动整体单元测试水平不断提升. 6. demo #import #import \"OCMock.h\" #import \"UTDataUtil.h\" @interface UTDataUtil () + (NSInteger)minThreshold; + (NSInteger)maxThreshold; + (void)handleLoadSuccessWithInfo:(NSDictionary *)info; + (void)handleLoadFailWithInfo:(NSDictionary *)info; + (void)showError:(BOOL)show; @end @interface UTDataUtilTest : XCTestCase @property(nonatomic, strong) id mock; @end @implementation UTDataUtilTest - (void)setUp { _mock = OCMClassMock([UTDataUtil class]); OCMStub([_mock minThreshold]).andReturn(10); OCMStub([_mock maxThreshold]).andReturn(100); } - (void)tearDown { [_mock stopMocking]; } /// 将数字转化为字符串，验证转换逻辑是否正确 /// @discussion 大于等于10万时，展示xx万，不带小数点 /// @discussion 大于等于1万时，展示1.x万，保留一位小数点 /// @discussion 低于1万时，展示实际数字 - (void)testDescForCount { { NSInteger count = 100000; NSString *desc = [UTDataUtil descForCount:count]; XCTAssertEqualObjects(desc, @\"10万\"); } { NSInteger count = 10000; NSString *desc = [UTDataUtil descForCount:count]; XCTAssertEqualObjects(desc, @\"1.0万\"); } { NSInteger count = 1; NSString *desc = [UTDataUtil descForCount:count]; XCTAssertEqualObjects(desc, @\"1\"); } } - (void)testAsyncFetchCount { XCTestExpectation *expect = [self expectationWithDescription:@\"asyncFetchCount\"]; [UTDataUtil asyncFetchCountCompletion:^(NSInteger count) { XCTAssertEqual(count, 1); [expect fulfill]; }]; [self waitForExpectations:@[expect] timeout:0.5]; } /// 获取处理后的数字，验证数字处理逻辑是否正确 /// @discussion 大于阈值时，返回 原始数字 + 阈值 /// @discussion 小于阈值时，返回 0 /// @discussion 否则，返回原始数字 - (void)testProcessedCount { { NSInteger origCount = 9; NSInteger result = [UTDataUtil processedCount:origCount]; XCTAssertEqual(result, 0); } { NSInteger origCount = 101; NSInteger result = [UTDataUtil processedCount:origCount]; XCTAssertEqual(result, 201); } { NSInteger origCount = 50; NSInteger result = [UTDataUtil processedCount:origCount]; XCTAssertEqual(result, 50); } } ///// 使用OCMock验证代码是否执行 - (void)testHandleLoadFinished { { NSDictionary *info = @{@\"testKey\": @\"data\"}; id mock = OCMClassMock([UTDataUtil class]); OCMExpect([mock handleLoadSuccessWithInfo:[OCMArg any]]); OCMReject([mock handleLoadFailWithInfo:[OCMArg any]]); [UTDataUtil handleLoadFinished:info]; OCMVerifyAll(mock); [mock stopMocking]; } { NSDictionary *info = @{}; id mock = OCMClassMock([UTDataUtil class]); OCMExpect([mock handleLoadFailWithInfo:[OCMArg any]]); OCMReject([mock handleLoadSuccessWithInfo:[OCMArg any]]); [UTDataUtil handleLoadFinished:info]; OCMVerifyAll(mock); [mock stopMocking]; } } @end By yvan            last update： 2022-09-22 02:14:20 "},"CleanCoder/Flutter-Unit-Testing.html":{"url":"CleanCoder/Flutter-Unit-Testing.html","title":"Flutter单元测试(todo)","keywords":"","body":"todo By yvan            last update： 2022-09-22 02:14:20 "},"CleanCoder/performance_iOS.html":{"url":"CleanCoder/performance_iOS.html","title":"iOS性能度量(todo)","keywords":"","body":"TODO.. By yvan            last update： 2022-09-22 02:14:20 "},"CleanCoder/performance_flutter.html":{"url":"CleanCoder/performance_flutter.html","title":"Flutter性能度量(todo)","keywords":"","body":"todo By yvan            last update： 2022-09-22 02:14:20 "},"Design/feed.html":{"url":"Design/feed.html","title":"视频feed流设计(todo)","keywords":"","body":" By yvan            last update： 2022-09-22 02:14:20 "},"Design/task.html":{"url":"Design/task.html","title":"上传下载任务列表设计(todo)","keywords":"","body":" By yvan            last update： 2022-09-22 02:14:20 "}}